---
title: 索引失效
date: 2022-10-30T19:52:25Z
lastmod: 2023-01-29T18:12:51Z
---

# 索引失效

## expain (sql语句)

- id:选择标识符
  - 查询序列号
- select_type:表示查询的类型。
  - **simple**：简单查询。查询不包含子查询和union
  - **primary**：复杂查询中最外层的 select
  - **subquery**：包含在 select 中的子查询（不在 from 子句中）
  - **derived**：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为派生表
  - **union**：在 union 中的第二个和随后的 select
  - **union result**：从 union 临时表检索结果的 select
- table:输出结果集的表
  - 当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。
  - 当有 union 时，UNION RESULT 的 table 列的值为 <union1,2>，1和2表示参与 union 的 select 行id
- partitions:匹配的分区
- type:表示表的连接类型(system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL)
  - **NULL**：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引
  - **const, system**：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果）。用于 primary key 或 unique key 的所有列与常数比较时，所以表最多有一个匹配行，读取1次，速度比较快。
  - **eq_ref**：primary key 或 unique key 索引的所有部分被连接使用 ，最多只会返回一条符合条件的记录。简单的 select 查询不会出现这种 type
  - **ref**：相比 eq_ref，不使用唯一索引，而是使用普通索引或者唯一性索引的部分前缀，索引要和某个值相比较，可能会找到多个符合条件的行
  - **ref_or_null**：类似ref，但是可以搜索值为NULL的行
  - **index_merge**：表示使用了索引合并的优化方法。
  - **range**：范围扫描通常出现在 in(), between ,> ,<, >= 等操作中。使用一个索引来检索给定范围的行。
  - **index**：和ALL一样，不同就是mysql只需扫描索引树，这通常比ALL快一些。
  - **ALL**：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了
- possible_keys:表示查询时，可能使用的索引
  - explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。
  - 如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。
- key:表示实际使用的索引
  - 显示mysql实际采用哪个索引来优化对该表的访问。如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索引，在查询中使用 force index、ignore index
- key_len:索引字段的长度
  - 显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列
- ref:列与索引的比较
  - 显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），func，NULL，字段名（例：film.id）
- rows:扫描出的行数(估算的行数)
  - mysql估计要读取并检测的行数，注意这个不是结果集里的行数
- filtered:按表条件过滤的行百分比
- Extra:执行情况的描述和说明

## **全值匹配(最好)**

- 建立复合索引(name,age,salary) 示例：

```sql
create (unique) index idx_name_dep_age on employee(name,dep_id,age);
```

## **最佳左前缀法则**

　　如果索引的多列,要遵守最左前缀法则,指的就是从索引的最左列开始 并且不跳过索引中的列

- 跳过第一个,索引失效
- 跳过前两个, 索引失效
- 跳过中间一个 ,只有第一个生效
- 顺序可以乱

## 不在索引列上做任何操作

- 计算,函数,类型转换会导致索引失效而转向全表扫描

## 范围条件右边的索引失效

### !=或者<>

- 在使用不等于(!=或者<>)的时候无法使用索引会导致全表扫描
- is not null 无法使用索引

### or 引起索引失效

　　少用 or 用 or 连接时, 会导致索引失效

### like 引起索引失效

　　like 以通配符开头(%qw)索引失效变成全表扫描

- 使用%开头
- 使用%结尾
- 使用覆盖索引解决两边%

### 字符串不加引号索引失效

## 覆盖索引

　　覆盖索引 查询的字段和建立的字段刚好吻合,这种我们称为覆盖索引

## 索引下推

- 在 MySQL 5.6 之前，只能从 命中的第一个开始一个个回表。到主键索引上找出数据行，再对比字段值。
- 而 MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。

## 重建索引

- **为何要索引重建**
  - 索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间。
- **重建普通索引和重建主键索引**
  - 重建普通索引可以达到省空间的目的
  - 重建主键索引，删除主键还是创建主键，都会将整个表重建。可以用这个语句代替 ： alter table T engine=InnoDB

## 联合索引技巧

- 覆盖索引：如果查询条件使用的是普通索引（或是联合索引的最左原则字段），查询结果是联合索引的字段或是主键，不用回表操作，直接返回结果，减少IO磁盘读写读取正行数据
- 最左前缀：联合索引的最左 N 个字段，也可以是字符串索引的最左 M 个字符
- 联合索引：根据创建联合索引的顺序，以最左原则进行where检索，比如（age，name）以age=1 或 age= 1 and name=‘张三’可以使用索引，单以name=‘张三’ 不会使用索引，考虑到存储空间的问题，还请根据业务需求，将查找频繁的数据进行靠左创建索引。
- 索引下推：like 'hello%’and age >10 检索，MySQL5.6版本之前，会对匹配的数据进行回表查询。5.6版本后，会先过滤掉age<10的数据，再进行回表查询，减少回表率，提升检索速度

　　‍
